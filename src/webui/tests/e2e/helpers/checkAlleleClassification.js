let AlleleSidebar = require('../pageobjects/alleleSidebar')
let AlleleSectionBox = require('../pageobjects/alleleSectionBox')

let util = require('../pageobjects/util')

let alleleSidebar = new AlleleSidebar()
let alleleSectionBox = new AlleleSectionBox()

const SELECTOR_COMMENT_CLASSIFICATION_EDITOR =
    'allele-sectionbox .id-comment-classification .wysiwygeditor'

/**
 *
 * Checks the input allele classification data against content in the UI. If the input has more than
 * one allele, we use the allele sidebar to load allele.
 *
 * @param {any} allele_data
 */
function checkAlleleClassification(allele_data, workflowType = 'analysis') {
    for (let [allele, data] of Object.entries(allele_data)) {
        util.log(`checking classification for allele ${allele}`)

        if ('technical' in data) {
            if (workflowType === 'analysis') {
                expect(alleleSidebar.isAlleleInTechnical(allele)).toBe(true)
                alleleSidebar.selectTechnicalAllele(allele)
            } else {
                throw Error(`Invalid check for workflow type ${workflowType}`)
            }
        } else if ('notRelevant' in data) {
            if (workflowType === 'analysis') {
                expect(alleleSidebar.isAlleleInNotRelevant(allele)).toBe(true)
                alleleSidebar.selectNotRelevantAllele(allele)
            } else {
                throw Error(`Invalid check for workflow type ${workflowType}`)
            }
        } else if ('classification' in data) {
            if (workflowType === 'analysis') {
                expect(alleleSidebar.isAlleleInClassified(allele)).toBe(true)
                alleleSidebar.selectClassifiedAllele(allele)
                expect(alleleSidebar.getSelectedAlleleClassification().current).toEqual(
                    data.classification
                )
            }
            // the 'string' prefix of the option value is auto-generated by Angular:
            expect(alleleSectionBox.getClassificationValue()).toEqual(
                'string:' + data.classification
            )
        }

        if ('analysisComment' in data) {
            expect(alleleSectionBox.analysisComment).toEqual(data.analysisComment)
        }

        if ('reviewed' in data) {
            expect(alleleSidebar.isMarkedReviewed(allele)).toBe(data.reviewed)
        }

        if ('references' in data) {
            for (let [idx, ref_data] of Object.entries(data.references)) {
                expect(alleleSectionBox.getReferenceComment(idx)).toEqual(ref_data.comment)
            }
        }

        if ('evaluation' in data) {
            expect(alleleSectionBox.classificationComment).toEqual(data.evaluation)
        }
        if ('frequency' in data) {
            expect(alleleSectionBox.frequencyComment).toEqual(data.frequency)
        }
        if ('prediction' in data) {
            expect(alleleSectionBox.predictionComment).toEqual(data.prediction)
        }
        if ('external' in data) {
            expect(alleleSectionBox.externalComment).toEqual(data.external)
        }
        if ('report' in data) {
            expect(alleleSectionBox.reportComment).toEqual(data.report)
        }
        if ('num_attachments' in data) {
            expect(alleleSectionBox.getNumberOfAttachments()).toEqual(data.num_attachments)
        }

        if ('acmg' in data) {
            for (let [idx, acmg_data] of Object.entries(data.acmg)) {
                expect(alleleSectionBox.getAcmgCode(idx)).toEqual(acmg_data.code)
                expect(alleleSectionBox.getAcmgComment(idx)).toEqual(acmg_data.comment)
            }
        }
    }
}

module.exports = checkAlleleClassification
